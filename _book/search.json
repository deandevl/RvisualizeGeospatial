[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Visualizing geospatial data in R",
    "section": "",
    "text": "Introduction\n\nThe following R script was inspired by a tutorial article Visualizing geospatial data in R posted November 24, 2020 by Nathaniel Schmucker in R bloggers.\nFrom the article:\n\nIn the tutorials in this series, we will introduce GIS data visualization in R using the simple features standard, which has become increasingly popular in recent years and which has the smallest learning curve for those who are already comfortable with data frames and the principles of the “tidyverse.” The simple features approach works well for many common map-making applications, including drawing regions (e.g., states) or points (e.g., cities) and coloring them to create an analytical insight (e.g., shading by population density).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Tutorial on GIS data visualiztion in R</span>"
    ]
  },
  {
    "objectID": "part_1.html",
    "href": "part_1.html",
    "title": "Part 1: Finding, loading, and cleaning data",
    "section": "",
    "text": "Setup\nLoad the required R packages from CRAN and github.\nFrom CRAN:\nlibrary(here)\nlibrary(data.table)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(rnaturalearth)\nlibrary(devtools)\nlibrary(kableExtra)\nFrom github:\ndevtools::install_github(\"deandevl/RspatialPkg\")\ndevtools::install_github(\"deandevl/RcensusPkg\")\nDefine the file path to the shapefiles folder at the root of this Rstudio project for holding downloaded shapefiles:\nshapefile_directory &lt;- file.path(here(), \"shapefiles\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Part 1: Finding, loading, and cleaning data</span>"
    ]
  },
  {
    "objectID": "part_1.html#introduction",
    "href": "part_1.html#introduction",
    "title": "Part 1: Finding, loading, and cleaning data",
    "section": "Introduction",
    "text": "Introduction\n\nIf you want to draw state borders (polygons), county borders (more polygons), major highways (lines), and highway rest stops (points), add each of them as an individual layer to the same plot, and color them as you please. There are no constraints when visualizing geospatial data in R.\n\n\nThis post will focus on how to find, import, and clean geospatial data. The actual graphing will come in Part 2 (static maps with ggplot2) and Part 3 (interactive maps with leaflet).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Part 1: Finding, loading, and cleaning data</span>"
    ]
  },
  {
    "objectID": "part_1.html#a-brief-introduction-to-simple-features-data-in-r",
    "href": "part_1.html#a-brief-introduction-to-simple-features-data-in-r",
    "title": "Part 1: Finding, loading, and cleaning data",
    "section": "A brief introduction to simple features data in R",
    "text": "A brief introduction to simple features data in R\n\nOut in the wild, map data most frequntly comes as either geoJSON files (.geojson) or Shapefiles (.shp). These files will, at the very minimum, contain information about the geometry of each object to be drawn, such as instructions to draw a point in a certain location or to draw a polygon with certain dimensions. The raw file may, however, also contain any amount of additional information, such as a name for the object (“Pennsylvania”), or summary statistics (GDP per capita, total population, etc.).\n\n\nRead raw shapefile data from “OpenDataPhilly”.\n\n\nzip_geojson &lt;- \"http://data.phl.opendata.arcgis.com/datasets/b54ec5210cee41c3a884c9086f7af1be_0.geojson\"\nphl_zip_raw_sf &lt;- sf::read_sf(zip_geojson)\n\n\n\n\n\nSimple feature of “OpenDataPhilly”\n\n\nOBJECTID\nCODE\nCOD\nShape__Area\nShape__Length\ngeometry\n\n\n\n\n1\n19120\n20\n91779697\n49921.54\nPOLYGON ((-75.11107 40.0468...\n\n\n2\n19121\n21\n69598787\n39534.89\nPOLYGON ((-75.19227 39.9946...\n\n\n3\n19122\n22\n35916319\n24124.65\nPOLYGON ((-75.15406 39.9860...\n\n\n4\n19123\n23\n35851751\n26421.73\nPOLYGON ((-75.1519 39.97056...\n\n\n5\n19124\n24\n144808025\n63658.77\nPOLYGON ((-75.0966 40.04249...\n\n\n6\n19125\n25\n48226254\n30113.60\nPOLYGON ((-75.10849 39.9703...\n\n\n\n\n\n\n\n\n\nhead(phl_zip_raw_sf)\n\nSimple feature collection with 6 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -75.20435 ymin: 39.95577 xmax: -75.06099 ymax: 40.05317\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 6\n  OBJECTID CODE    COD Shape__Area Shape__Length                        geometry\n     &lt;int&gt; &lt;chr&gt; &lt;int&gt;       &lt;dbl&gt;         &lt;dbl&gt;                   &lt;POLYGON [°]&gt;\n1        1 19120    20   91779697.        49922. ((-75.11107 40.04682, -75.1094…\n2        2 19121    21   69598787.        39535. ((-75.19227 39.99463, -75.1920…\n3        3 19122    22   35916319.        24125. ((-75.15406 39.98601, -75.1532…\n4        4 19123    23   35851751.        26422. ((-75.1519 39.97056, -75.1515 …\n5        5 19124    24  144808025.        63659. ((-75.0966 40.04249, -75.09281…\n6        6 19125    25   48226254.        30114. ((-75.10849 39.9703, -75.11051…\n\n\n\nWe are told the Coordinate Reference System (CRS), which in this case is “WGS 84.” CRSs are cartographers’ ways of telling each other what system they used for describing points on the earth. Cartographers need to pick an equation for an ellipsoid to approximate earth’s shape since it’s slightly pear-shaped. Cartographers also need to determine a set of reference markers–known as a datum–to use to set coordinates, as earth’s tectonic plates shift ever so slightly over time. Together, the ellipsoid and datum become a CRS.\n\n\nWGS 84 is one of the most common CRSs and is the standard used for GPS applications. In the US, you may see data provided using NAD 83. WGS 84 and NAD 83 were originally identical (back in the 1980s), but both have been modified over time as the earth changes and scientific knowledge progresses. WGS 84 seeks to keep the global average of points as similar as possible while NAD 83 tries to keep the North American plate as constant as possible. The net result is that the two different CRSs may vary by about a meter in different places. This is not a big difference for most purposes, but sometimes you may need to adjust.\n\n\nIf we wanted to transform our data between CRSs, we would call sf::st_transform(map_raw, crs = 4326), where 4362 is the EPSG code of the CRS into which we would like to transform our geometry. EPSGs are a standard, shorthand way to refer to various CRSs. 4326 is the EPSG code for WGS 84 and 4269 is the EPSG code for NAD 83.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Part 1: Finding, loading, and cleaning data</span>"
    ]
  },
  {
    "objectID": "part_1.html#finding-data",
    "href": "part_1.html#finding-data",
    "title": "Part 1: Finding, loading, and cleaning data",
    "section": "Finding data",
    "text": "Finding data\n\nThe trouble comes in trying to find the data you need–both the geometry and the proper additional fields–and getting them together into the same object in R.\n\n\nFinding geospatial data\n\nImport US Census Bureau county data from Pennsylvania.\n\n\npenn_fips &lt;- usmap::fips(state = \"pennsylvania\")\nexpress &lt;- expression(STATEFP == penn_fips)\npenn_cty_sf &lt;- RcensusPkg::tiger_counties_sf(\n  output_dir = shapefile_directory,\n  vintage = 2018,\n  general = TRUE,\n  resol = \"20m\",\n  express = express,\n  sf_info = FALSE\n) %&gt;% \n  data.table::as.data.table(.) %&gt;% \n  .[, .(GEOID, NAME, COUNTYFP, COUNTYNS, geometry)] %&gt;% \n  .[, NAME := toupper(NAME)] %&gt;% \n  data.table::setnames(., old = \"NAME\", new = \"COUNTY\") %&gt;% \n  sf::st_as_sf(.)\n\n\n\n\n\nSimple feature of Pennsylvania\n\n\nGEOID\nCOUNTY\nCOUNTYFP\nCOUNTYNS\ngeometry\n\n\n\n\n42113\nSULLIVAN\n113\n01213687\nMULTIPOLYGON (((-76.81373 4...\n\n\n42015\nBRADFORD\n015\n01213660\nMULTIPOLYGON (((-76.92685 4...\n\n\n42099\nPERRY\n099\n01213682\nMULTIPOLYGON (((-77.67176 4...\n\n\n42035\nCLINTON\n035\n01214721\nMULTIPOLYGON (((-78.09338 4...\n\n\n42075\nLEBANON\n075\n01214034\nMULTIPOLYGON (((-76.67804 4...\n\n\n42007\nBEAVER\n007\n01214112\nMULTIPOLYGON (((-80.51971 4...\n\n\n\n\n\n\n\n\n\nRspatialPkg::get_geom_sf(\n  sf = penn_cty_sf,\n  hide_x_tics = T,\n  hide_y_tics = T,\n  panel_color = \"white\",\n  panel_border_color = \"white\"\n)\n\n\n\n\nBasic map of PA counties, Source: U.S. Census Bureau TIGER/Line Shapefiles.\n\n\n\n\n\nFor non-US applications, use the package rnaturalearth which provides easy access to global data.\n\n\nasia_sf &lt;- rnaturalearth::ne_countries(\n  continent = \"Asia\",\n  returnclass = \"sf\"\n)\n\n\nRspatialPkg::get_geom_sf(\n  sf = asia_sf,\n  hide_x_tics = T,\n  hide_y_tics = T,\n  panel_color = \"white\",\n  panel_border_color = \"white\"\n)\n\n\n\n\nBasic map of countries in Asia. Source: rnaturalearth package.\n\n\n\n\n\n\nFinding non-geospatial data\n\nChances are that you are coming to a geospatial mapping project with a particular dataset in mind.\n\n\n…Hopefully, your data has an ID that you can use to identify each geospatial region.\n\n\nJoin PA’s Department of Health hospital data with PA’s county geometries.\n\n\nRead the source data:\n\n\npa_hospitals_csv_path &lt;- file.path(here(), \"data\", \"DOH_Hospitals201912.csv\")\npa_hospitals_raw_dt &lt;- data.table::fread(file = pa_hospitals_csv_path) %&gt;%\n  .[, .(FACILITY_N,COUNTY)] %&gt;% \n  .[, COUNTY := trimws(COUNTY)]\n\n\nGroup pa_hospitals_raw_dt by “COUNTY” and create a column with the number of facilities:\n\n\npa_hospitals_grouped_dt &lt;- pa_hospitals_raw_dt[, .(N_Facility = .N), by = COUNTY] %&gt;% \n  .[order(COUNTY),]\n\n\n\n\n\nTotal Pennsylvania hospitals by county\n\n\nCOUNTY\nN_Facility\n\n\n\n\nADAMS\n1\n\n\nALLEGHENY\n28\n\n\nARMSTRONG\n1\n\n\nBEAVER\n2\n\n\nBEDFORD\n1\n\n\nBERKS\n6\n\n\n\n\n\n\n\n\n\nGet the PA county populations from the US Census Bureau:\n\n\npa_cty_pop_dt &lt;- RcensusPkg::get_vintage_data(\n  dataset = \"dec/pl\",\n  vintage = 2020,\n  vars = \"P1_001N\",\n  region = \"county:*\",\n  regionin = paste0(\"state:\", penn_fips)  \n) %&gt;% \n  .[, .(GEOID, NAME, P1_001N)] %&gt;% \n  .[, c(\"COUNTY\", \"State_str\") := tstrsplit(NAME, \"County,\")] %&gt;% \n  .[, COUNTY := trimws(toupper(COUNTY))] %&gt;% \n  data.table::setnames(., old = \"P1_001N\", new = \"Cty_Pop\") %&gt;% \n  .[, .(COUNTY, Cty_Pop)] %&gt;% \n  .[order(COUNTY),]\n\n\n\n\n\nPennsylvania populations by county\n\n\nCOUNTY\nCty_Pop\n\n\n\n\nADAMS\n103852\n\n\nALLEGHENY\n1250578\n\n\nARMSTRONG\n65558\n\n\nBEAVER\n168215\n\n\nBEDFORD\n47577\n\n\nBERKS\n428849\n\n\n\n\n\n\n\n\n\nJoin the values of pa_hospitals_grouped_dt with pa_cty_pop_dt using their common variable “COUNTY”:\n\n\ndata.table::setkeyv(pa_hospitals_grouped_dt, \"COUNTY\")\ndata.table::setkeyv(pa_cty_pop_dt, \"COUNTY\")\n\npa_hospitals_pop_dt &lt;- pa_cty_pop_dt[pa_hospitals_grouped_dt] %&gt;% \n  .[, `:=`(Cty_Pop = as.numeric(Cty_Pop))]\n\n\n\n\n\nPennsylvania populations joined with hospital totals by county\n\n\nCOUNTY\nCty_Pop\nN_Facility\n\n\n\n\nADAMS\n103852\n1\n\n\nALLEGHENY\n1250578\n28\n\n\nARMSTRONG\n65558\n1\n\n\nBEAVER\n168215\n2\n\n\nBEDFORD\n47577\n1\n\n\nBERKS\n428849\n6\n\n\n\n\n\n\n\n\n\nAdd a column to the joined data.table pa_hospitals_pop_dt that divides “N_Facility” by “Cty_Pop”:\n\n\npa_hospitals_pop_dt[, Hosp_Per_1M := N_Facility / (Cty_Pop/1000000)]\n\n\nJoin the county geometries with the hospital data:\n\n\npa_hospitals_pop_dt &lt;- RcensusPkg::join_it(\n  df_1 = pa_hospitals_pop_dt,\n  df_2 = penn_cty_sf,\n  key_1 = \"COUNTY\",\n  key_2 = \"COUNTY\"\n)\n\n\nMap the geometries and hospital data:\n\n\nRspatialPkg::get_geom_sf(\n  sf = sf::st_as_sf(pa_hospitals_pop_dt),\n  aes_fill = \"Hosp_Per_1M\",\n  own_scale = T,\n  hide_x_tics = T,\n  hide_y_tics = T,\n  panel_color = \"white\",\n  panel_border_color = \"white\",\n  legend_key_width = 0.7,\n  legend_key_height = 0.7\n) +\n  ggplot2::scale_fill_viridis_c()\n\n\n\n\nHospitals per million residents. Montour County is apparently the place to be if you need a hospital!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Part 1: Finding, loading, and cleaning data</span>"
    ]
  },
  {
    "objectID": "part_2.html",
    "href": "part_2.html",
    "title": "Part 2: Making maps with ggplot2",
    "section": "",
    "text": "Setup\nLoad the required R packages from CRAN and github.\nFrom CRAN:\nlibrary(here)\nlibrary(data.table)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(rnaturalearth)\nlibrary(devtools)\nlibrary(kableExtra)\nFrom github:\ndevtools::install_github(\"deandevl/RspatialPkg\")\nDefine the file path to the shapefiles folder at the root of this Rstudio project for holding downloaded shapefiles:\nshapefile_directory &lt;- file.path(here(), \"shapefiles\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#review-load-and-clean-data",
    "href": "part_2.html#review-load-and-clean-data",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Review: Load and clean data",
    "text": "Review: Load and clean data\n\nThe first dataset is a .geojson file containing geospatial descriptions of Philadelphia’s neighborhoods, courtesy of OpenDataPhilly. This dataset is polygon data and will form our basemap for layering on additional, more interesting, features.\n\n\nThe second dataset, also courtesy of OpenDataPhilly is our dataset of interest: a 2024 inventory of all of the trees in Philadelphia. This dataset is point data, where each tree has associated coordinates for identifying its precise location.\n\n\nLoad the data\n\nRead in the Philadelphia neighborhood data.\n\n\nneighborhoods_file_path &lt;- file.path(here(), \"data\", \"philadelphia-neighborhoods.geojson\")\n\nneighborhoods_raw_sf &lt;- sf::read_sf(neighborhoods_file_path)\nsf::st_crs(neighborhoods_raw_sf) = 4326\n\n\n\n\n\nPhiladelphia Neighborhoods\n\n\nNAME\nLISTNAME\nMAPNAME\nShape_Leng\nShape_Area\ngeometry\n\n\n\n\nBRIDESBURG\nBridesburg\nBridesburg\n27814.55\n44586264\nMULTIPOLYGON (((-75.06773 4...\n\n\nBUSTLETON\nBustleton\nBustleton\n48868.46\n114050424\nMULTIPOLYGON (((-75.0156 40...\n\n\nCEDARBROOK\nCedarbrook\nCedarbrook\n20021.42\n24871745\nMULTIPOLYGON (((-75.18848 4...\n\n\nCHESTNUT_HILL\nChestnut Hill\nChestnut Hill\n56394.30\n79664975\nMULTIPOLYGON (((-75.21221 4...\n\n\nEAST_FALLS\nEast Falls\nEast Falls\n27400.78\n40576888\nMULTIPOLYGON (((-75.18476 4...\n\n\nMOUNT_AIRY_EAST\nMount Airy, East\nEast Mount Airy\n28845.55\n43152470\nMULTIPOLYGON (((-75.18087 4...\n\n\n\n\n\n\n\n\n\nRead in the Philadelphia tree data.\n\n\ntrees_file_path &lt;- file.path(here(), \"data\", \"ppr_tree_inventory_2024.csv\")\n\ntrees_raw_sf &lt;- sf::read_sf(trees_file_path) %&gt;% \n  data.table::as.data.table(.) %&gt;% \n  .[, `:=`(loc_x = as.numeric(loc_x), loc_y = as.numeric(loc_y))] %&gt;% \n  sf::st_as_sf(., coords = c(\"loc_x\",\"loc_y\"))  \nsf::st_crs(trees_raw_sf) = 4326  \n\n\n\n\n\nPhiladelphia Trees\n\n\nX\nY\nobjectid\ntree_name\ntree_dbh\nyear\ngeometry\n\n\n\n\n-8369286.62738524\n4856867.3859829\n1\nACER PLATANOIDES - NORWAY MAPLE\n13\n2024\nPOINT (-75.18258 39.93751)\n\n\n-8368484.91003424\n4857247.60294763\n2\nACER PLATANOIDES - NORWAY MAPLE\n16\n2024\nPOINT (-75.17538 39.94013)\n\n\n-8368573.28327579\n4857533.37906856\n3\nACER PLATANOIDES - NORWAY MAPLE\n11\n2024\nPOINT (-75.17617 39.9421)\n\n\n-8369018.20752659\n4857334.00314431\n4\nSOPHORA JAPONICA - JAPANESE PAGODA TREE\n16\n2024\nPOINT (-75.18017 39.94073)\n\n\n-8368196.28454208\n4857325.20869328\n5\nOSTRYA VIRGINIANA - EASTERN HOP HORNBEAM\n2\n2024\nPOINT (-75.17278 39.94067)\n\n\n-8368169.44953092\n4857418.7633857\n6\nACER RUBRUM - RED MAPLE\n5\n2024\nPOINT (-75.17254 39.94131)\n\n\n\n\n\n\n\n\n\n\nClean the data\n\nIn the neighborhood data, rename columns; add “Area” column which converts square footage to acres.\n\n\nneighborhoods_raw_sf &lt;- data.table::as.data.table(neighborhoods_raw_sf) %&gt;%\n  data.table::setnames(., old = \"MAPNAME\", new =\"Label\") %&gt;% \n  .[, Area := Shape_Area/43560] %&gt;% \n  sf::st_as_sf(.)\n\n\n\nSimple feature collection with 6 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -75.23049 ymin: 39.98491 xmax: -75.0156 ymax: 40.11269\nGeodetic CRS:  WGS 84\n             NAME         LISTNAME           Label Shape_Leng Shape_Area\n1      BRIDESBURG       Bridesburg      Bridesburg   27814.55   44586264\n2       BUSTLETON        Bustleton       Bustleton   48868.46  114050424\n3      CEDARBROOK       Cedarbrook      Cedarbrook   20021.42   24871745\n4   CHESTNUT_HILL    Chestnut Hill   Chestnut Hill   56394.30   79664975\n5      EAST_FALLS       East Falls      East Falls   27400.78   40576888\n6 MOUNT_AIRY_EAST Mount Airy, East East Mount Airy   28845.55   43152470\n       Area                       geometry\n1 1023.5598 MULTIPOLYGON (((-75.06773 4...\n2 2618.2375 MULTIPOLYGON (((-75.0156 40...\n3  570.9767 MULTIPOLYGON (((-75.18848 4...\n4 1828.8562 MULTIPOLYGON (((-75.21221 4...\n5  931.5172 MULTIPOLYGON (((-75.18476 4...\n6  990.6444 MULTIPOLYGON (((-75.18087 4...\n\n\n\nIn the tree data, rename a column.\n\n\ntrees_raw_sf &lt;- data.table::as.data.table(trees_raw_sf) %&gt;% \n  data.table::setnames(., old = \"objectid\", new = \"Tree_ID\") %&gt;% \n  .[, Tree_ID := as.numeric(Tree_ID)] %&gt;% \n  sf::st_as_sf(.)\n\n\n\nSimple feature collection with 6 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -75.18258 ymin: 39.93751 xmax: -75.17254 ymax: 39.9421\nGeodetic CRS:  WGS 84\n                  X                Y Tree_ID\n1 -8369286.62738524  4856867.3859829       1\n2 -8368484.91003424 4857247.60294763       2\n3 -8368573.28327579 4857533.37906856       3\n4 -8369018.20752659 4857334.00314431       4\n5 -8368196.28454208 4857325.20869328       5\n6 -8368169.44953092  4857418.7633857       6\n                                 tree_name tree_dbh year\n1          ACER PLATANOIDES - NORWAY MAPLE       13 2024\n2          ACER PLATANOIDES - NORWAY MAPLE       16 2024\n3          ACER PLATANOIDES - NORWAY MAPLE       11 2024\n4  SOPHORA JAPONICA - JAPANESE PAGODA TREE       16 2024\n5 OSTRYA VIRGINIANA - EASTERN HOP HORNBEAM        2 2024\n6                  ACER RUBRUM - RED MAPLE        5 2024\n                    geometry\n1 POINT (-75.18258 39.93751)\n2 POINT (-75.17538 39.94013)\n3  POINT (-75.17617 39.9421)\n4 POINT (-75.18017 39.94073)\n5 POINT (-75.17278 39.94067)\n6 POINT (-75.17254 39.94131)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#geospatial-layers-in-ggplot2",
    "href": "part_2.html#geospatial-layers-in-ggplot2",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Geospatial layers in ggplot2",
    "text": "Geospatial layers in ggplot2\n\nYour first map\n\nMap the two simple features by layering trees sf over the neighborhoods sf.\n\n\nRspatialPkg::get_geom_sf(\n  sf = neighborhoods_raw_sf\n) %&gt;% \n  RspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_raw_sf,\n  sf_color = \"#74b560\"\n)\n\n\n\n\nNeighborhoods around Philadelphia, PA with trees",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#zoom-in-on-a-region-of-interest",
    "href": "part_2.html#zoom-in-on-a-region-of-interest",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Zoom in on a region of interest",
    "text": "Zoom in on a region of interest",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#zoom-in-on-a-region-of-interest-1",
    "href": "part_2.html#zoom-in-on-a-region-of-interest-1",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Zoom in on a region of interest",
    "text": "Zoom in on a region of interest\n\nBy default, ggplot2 will zoom out so that all of the mapping objects are in the image. Suppose, however, that we are interested in a smaller region of the map: Center City Philadelphia.\n\n\nWe can use ggplot2::coord_sf() to specify the coordinates to display. By default, geom_sf() calls coord_sf() in the background, but by explicitly calling it ourselves, we can override the default parameters. Below, we will specify our latitude and longitude, and set expand = FALSE. By default, expand is true, which puts a small buffer around the coordinates we specify. It’s an aesthetic choice.\n\n\nIf you recall from Part 1 of this series, the CRS is the ellipsoid and datum used to reference points on the globe. ggplot2 will take the first CRS provided (in this case, in our neighborhoods dataset) and ensure that all subsequent layers use the same CRS. It automatically converts any mismatched CRSs to the first one provided. Using coord_sf(), we have options to change the CRS and the datum. Changing the datum won’t affect plotting, but will affect where graticules (latitude/longitude lines) are drawn if you choose to include them. By default, ggplot2 draws graticules using WGS 84 (EPSG: 4326), which happens to be the CRS of our two datasets. If we had needed to, we could have changed to NAD 83 (EPSG: 4269) using datum = sf::st_crs(4269).\n\n\nRspatialPkg::get_geom_sf(\n  sf = neighborhoods_raw_sf,\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_raw_sf,\n  sf_color = \"#74b560\",\n  sf_fill = \"#74b560\",\n  sf_size = 1.6,\n  xlim = c(-75.185, -75.13),\n  ylim = c(39.93, 39.96)\n)\n\n\n\n\nZoomed neighborhoods around Philadelphia, PA with trees",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#add-labels-for-clearer-communication",
    "href": "part_2.html#add-labels-for-clearer-communication",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Add labels for clearer communication",
    "text": "Add labels for clearer communication\n\nNow that we have zoomed in to a smaller region, we have space on our map to add labels.\n\n\nUse the “Label” column from our neighborhoods_raw_sf simple feature to label the zoomed suburbs.\n\n\nRspatialPkg::get_geom_sf(\n  sf = neighborhoods_raw_sf\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_raw_sf,\n  sf_color = \"#74b560\",\n  sf_fill = \"#74b560\",\n  sf_size = 1.6\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = neighborhoods_raw_sf,\n  aes_text = \"Label\",\n  text_fontface = \"bold\",\n  text_check_overlap = T,\n  sf_alpha = 0,\n  xlim = c(-75.185, -75.13),\n  ylim = c(39.93, 39.96)\n)\n\n\n\n\nNeighborhoods around Philadelphia, PA with labels and trees.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#add-highlights-and-annotations",
    "href": "part_2.html#add-highlights-and-annotations",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Add highlights and annotations",
    "text": "Add highlights and annotations\n\nI want to highlight and annotate my favorite tree. Since the highlight rule needs to be determined tree-by-tree, we need to adjust our simple features object and add an appropriate aesthetic call to our plot. First we adjust our simple features object by adding columns for the color group and the label text. Then, we adjust our plot by including aes(color = Color) to define color groups and simultaneously adding scale_color_manual() to specify the colors we want for each group. At the same time, we optionally set show.legend = FALSE to hide the legend. We also add the label text using geom_sf_label() using the aes(label = Label) to specify the text and other parameters to adjust how it appears on the plot.\n\n\nAdd “Color” and “Label” columns to trees_raw_sf simple feature and map to highlight a favorite tree.\n\nAdd the two new columns where “Color” is a numeric factor taking on values 1 or 0 and “Label” with “My favorite” or blank character string depending on “Tree_ID:\n\ntrees_highlight_sf &lt;- data.table::as.data.table(trees_raw_sf) %&gt;% \n  .[, `:=`(\n    #Color = ifelse(Tree_ID == 39547, \"#cb7123\", \"#74b560\"),\n    Color = ifelse(Tree_ID == 39547, 1, 0),\n    Label = ifelse(Tree_ID == 39547, \"My favorite\", \"\")\n  )] %&gt;% \n  .[, Color := as.factor(Color)] %&gt;% \n  sf::st_as_sf(.)\n\nMap with the new color and labels:\n\nRspatialPkg::get_geom_sf(\n  sf = neighborhoods_raw_sf,\n  aes_text = \"Label\",\n  text_fontface = \"bold\",\n  text_size = 4.5, \n  show_legend = F,\n  sf_alpha = 0\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_highlight_sf,\n  aes_fill = \"Color\",\n  own_scale = T,\n  sf_size = 2.5\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_highlight_sf,\n  aes_text = \"Label\",\n  text_color = \"#cb7123\",\n  text_fontface = \"bold\",\n  text_size = 3.5,\n  text_nudge_y = -0.0002,\n  xlim = c(-75.12, -75.09),\n  ylim = c(40.02, 40.035)\n) +\n   ggplot2::scale_fill_manual(values = c(\"#74b560\", \"#cb7123\"))\n\n\n\n\nMy favorite tree in Northwood, Philadelphia, PA.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#final-beautification",
    "href": "part_2.html#final-beautification",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Final beautification",
    "text": "Final beautification\n\nAdd titles, source note, background color.\n\n\nRspatialPkg::get_geom_sf(\n  sf = neighborhoods_raw_sf,\n  aes_text = \"Label\",\n  text_fontface = \"bold\",\n  text_size = 4.5, \n  show_legend = F,\n  sf_alpha = 0,\n  panel_color = grey(0.75),\n  panel_border_color = \"white\",\n  title = \"The Urban Forest of Northwood, Philadelphia, PA.\",\n  subtitle = \"2024 virtual assessment of Philadelphia's Street trees\",\n  caption = \"Source: OpenDataPhilly\",\n  x_title = \"Longitude\",\n  y_title = \"Latitude\"\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_highlight_sf,\n  aes_fill = \"Color\",\n  own_scale = T,\n  sf_size = 2.5\n) %&gt;% \nRspatialPkg::get_geom_sf(\n  gg = .,\n  sf = trees_highlight_sf,\n  aes_text = \"Label\",\n  text_color = \"#cb7123\",\n  text_fontface = \"bold\",\n  text_size = 3.5,\n  text_nudge_y = -0.0002,\n  xlim = c(-75.12, -75.09),\n  ylim = c(40.02, 40.035)\n) +\nggplot2::scale_fill_manual(values = c(\"#74b560\", \"#cb7123\")) +\nggplot2::theme(\n  panel.grid.major = ggplot2::element_line(\n    color = gray(0.5), linetype = \"dashed\", size = 0.5\n  )\n)\n\n\n\n\nMy favorite tree in Northwood, Philadelphia, PA.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_2.html#choropleths-in-ggplot2",
    "href": "part_2.html#choropleths-in-ggplot2",
    "title": "Part 2: Making maps with ggplot2",
    "section": "Choropleths in ggplot2",
    "text": "Choropleths in ggplot2\n\n…the concept of a “choropleth” map, which colors regions to represent a statistical variable. For instance, we may want to color our neighborhoods by the number of trees in each, or (more appropriately) the number of trees per acre.\n\n\nMerge and clean data\n\nJoin neighborhoods_raw_sf and trees_raw_sf via `sf::st_join().\n\n\nneighborhoods_valid_raw_sf &lt;- sf::st_make_valid(neighborhoods_raw_sf)\n\nneigh_tree_join_sf &lt;- sf::st_join(neighborhoods_valid_raw_sf, trees_raw_sf)\n\n\nConvert the join to a data.table, group, and create “Density” variable.\n\n\nneighborhoods_raw_dt &lt;- data.table::as.data.table(neighborhoods_raw_sf)\n\ncount_density_sf &lt;- data.table::as.data.table(neigh_tree_join_sf) %&gt;% \n  .[, .N, by = .(NAME, Area)] %&gt;% \n  .[, Density := N/Area] %&gt;% \n  neighborhoods_raw_dt[., on = c(\"NAME\", \"NAME\")] %&gt;% \n  sf::st_as_sf(.)\n\n\nUse the “Density” (trees per acre) variable to produce a choropleth map across the neighborhoods of Philadelphia, PA\n\n\nRspatialPkg::get_geom_sf(\n  sf = count_density_sf,\n  aes_fill = \"Density\",\n  own_scale = T,\n  title = \"The Urban Forest of Philadelphia\",\n  subtitle = \"Number of trees per acre\",\n  x_title = \"Longitude\",\n  y_title = \"Latitude\",\n  caption = \"Source: OpenDataPhilly\",\n  panel_color = grey(0.75),\n  panel_border_color = \"white\"\n) +\n  ggplot2::labs(\n    fill = \"Trees per acre\"\n  ) +\n  ggplot2::scale_fill_viridis_c(alpha = 0.75) +\n  ggplot2::theme(\n    panel.grid.major = ggplot2::element_line(\n      color = gray(0.5), linetype = \"dashed\", size = 0.5\n    )\n  )",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Part 2: Making maps with ggplot2</span>"
    ]
  },
  {
    "objectID": "part_3.html",
    "href": "part_3.html",
    "title": "Part 3: Making interactive maps with leaflet",
    "section": "",
    "text": "Setup\nLoad the required R packages from CRAN and github.\nFrom CRAN:\nlibrary(here)\nlibrary(data.table)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(leaflet)\nlibrary(sf)\nlibrary(devtools)\nlibrary(kableExtra)\nFrom github:\ndevtools::install_github(\"deandevl/RspatialPkg\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Part 3: Making interactive maps with leaflet</span>"
    ]
  },
  {
    "objectID": "part_3.html#introduction",
    "href": "part_3.html#introduction",
    "title": "Part 3: Making interactive maps with leaflet",
    "section": "Introduction",
    "text": "Introduction\n\nThe benefit of creating a JavaScript map over a .jpg map as we did in our last post is that the map is “slippy,” that is, it slips around inside its container. You can drag to pan, scroll to zoom, click to show popups, etc. The downside, however, is that, since leaflet creates a JavaScript map, the map can only be shared in an interactive environment like a web browser. As such, leaflet is not a good choice for pasting images in papers and presentations, or for setting a snazzy new desktop background. Go back to Maps, Part 2 for that.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Part 3: Making interactive maps with leaflet</span>"
    ]
  },
  {
    "objectID": "part_3.html#review-load-data",
    "href": "part_3.html#review-load-data",
    "title": "Part 3: Making interactive maps with leaflet",
    "section": "Review: Load data",
    "text": "Review: Load data\n\nThe first dataset is a .geojson file containing geospatial descriptions of Philadelphia’s neighborhoods, courtesy of OpenDataPhilly. This dataset is polygon data and will form our basemap for layering on additional, more interesting, features.\n\n\nThe second dataset is geospatial point data, also provided by OpenDataPhilly, that contains information from the police department on shooting victims.\n\n\nRead in the Philadelphia neighborhood data.\n\n\nneighborhoods_file_path &lt;- file.path(here(), \"data\", \"philadelphia-neighborhoods.geojson\")\n\nneighborhoods_raw_sf &lt;- sf::read_sf(neighborhoods_file_path)\nsf::st_crs(neighborhoods_raw_sf) = 4326\n\n\n\nSimple feature collection with 6 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -75.23049 ymin: 39.98491 xmax: -75.0156 ymax: 40.11269\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 6\n  NAME          LISTNAME MAPNAME Shape_Leng Shape_Area                  geometry\n  &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;        &lt;MULTIPOLYGON [°]&gt;\n1 BRIDESBURG    Bridesb… Brides…     27815.  44586264. (((-75.06773 40.0054, -7…\n2 BUSTLETON     Bustlet… Bustle…     48868. 114050424. (((-75.0156 40.09487, -7…\n3 CEDARBROOK    Cedarbr… Cedarb…     20021.  24871745. (((-75.18848 40.07273, -…\n4 CHESTNUT_HILL Chestnu… Chestn…     56394.  79664975. (((-75.21221 40.08604, -…\n5 EAST_FALLS    East Fa… East F…     27401.  40576888. (((-75.18476 40.02829, -…\n6 MOUNT_AIRY_E… Mount A… East M…     28846.  43152470. (((-75.18087 40.04325, -…\n\n\n\nRead in the Philadelphia shootings data\n\n\nshootings_file_path &lt;- file.path(here(), \"data\", \"philadelphia-shootings-2023.geojson\")\n\nshootings_raw_sf &lt;- sf::read_sf(shootings_file_path)\nsf::st_crs(shootings_raw_sf) = 4326\n\n\nhead(shootings_raw_sf)\n\nSimple feature collection with 6 features and 22 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -75.15338 ymin: 40.02221 xmax: -75.12371 ymax: 40.04969\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 23\n  cartodb_id objectid  year dc_key   code  date_               time  race  sex  \n       &lt;int&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt; &lt;dttm&gt;              &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1          1 16074191  2023 2023350… 300   2023-05-28 20:00:00 04:1… B     M    \n2          2 16074192  2023 2023350… 400   2023-06-02 20:00:00 17:0… B     M    \n3          3 16074193  2023 2023350… 400   2023-08-05 20:00:00 23:1… B     M    \n4          4 16074194  2023 2023350… 400   2023-06-03 20:00:00 22:3… B     M    \n5          5 16074195  2023 2023350… 400   2023-08-05 20:00:00 23:1… B     M    \n6          6 16074196  2023 2023350… 400   2023-08-05 20:00:00 23:1… W     M    \n# ℹ 14 more variables: age &lt;chr&gt;, wound &lt;chr&gt;, officer_involved &lt;chr&gt;,\n#   offender_injured &lt;chr&gt;, offender_deceased &lt;chr&gt;, location &lt;chr&gt;,\n#   latino &lt;int&gt;, point_x &lt;dbl&gt;, point_y &lt;dbl&gt;, dist &lt;chr&gt;, inside &lt;int&gt;,\n#   outside &lt;int&gt;, fatal &lt;int&gt;, geometry &lt;POINT [°]&gt;",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Part 3: Making interactive maps with leaflet</span>"
    ]
  },
  {
    "objectID": "part_3.html#review-clean-data",
    "href": "part_3.html#review-clean-data",
    "title": "Part 3: Making interactive maps with leaflet",
    "section": "Review: Clean data",
    "text": "Review: Clean data\n\nleaflet requires that data be in WGS 84, so we would need to convert to WGS 84 (EPSG code: 4326) using sf::st_transform(shootings_raw_sf, crs = 4326) if it weren’t provided to us with that CRS.\n\n\nIf we want to run non-geospatial analysis on our shootings data, such as plotting shootings over time, calculating totals by demographic, and so on, we can drop the geospatial information and work with a standard tibble using sf::st_drop_geometry(shootings_raw_sf).\n\n\nIn the neighborhood data, rename a column.\n\n\nneighborhoods_raw_sf &lt;- data.table::as.data.table(neighborhoods_raw_sf) %&gt;% \n  data.table::setnames(., old = \"MAPNAME\", new = \"Label\") %&gt;% \n  sf::st_as_sf(.)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Part 3: Making interactive maps with leaflet</span>"
    ]
  },
  {
    "objectID": "part_3.html#geospatial-layers-in-leaflet",
    "href": "part_3.html#geospatial-layers-in-leaflet",
    "title": "Part 3: Making interactive maps with leaflet",
    "section": "Geospatial layers in leaflet",
    "text": "Geospatial layers in leaflet\n\nYou have the option of loading data either as the data = … argument in leaflet::leaflet() or waiting until subsequent layers to provide the data. As in our last post, we will add the data in each layer, since we are working with two distinct datasets.\n\n\nYour first map\n\nleaflet::leaflet() %&gt;% \n  leaflet::addPolygons(data = neighborhoods_raw_sf) %&gt;% \n  leaflet::addCircles(data = shootings_raw_sf)\n\nWarning in validateCoords(lng, lat, funcName): Data contains 12 rows with\neither missing or invalid lat/lon values and will be ignored\n\n\n\n\nBasic map of Philadelphia gun violence using leaflet. Source: OpenDataPhilly.\n\n\n\n\nAdd a basemap\n\nThe leaflet package makes it easy to add map tiles, or “basemaps” to the layperson. You can either choose to call addTiles() with no arguments to get the default basemap from OpenStreetMap or choose to call addProviderTiles() to get one of the various third-party options. Our favorite is CartoDB.Voyager, but you can explore the entire set of options and pick your favorite.\n\n\nleaflet::leaflet() %&gt;% \n  leaflet::addProviderTiles(providers$CartoDB.Voyager) %&gt;% \n  leaflet::addPolygons(data = neighborhoods_raw_sf) %&gt;% \n  leaflet::addCircles(data = shootings_raw_sf)\n\nWarning in validateCoords(lng, lat, funcName): Data contains 12 rows with\neither missing or invalid lat/lon values and will be ignored\n\n\n\n\nLeaflet map with provider tiles. Source: OpenDataPhilly.\n\n\n\n\nSimple formatting adjustments\n\nLet’s make some basic formatting adjustments to the polygons layer: line color, line weight, line opacity, and fill opacity (0 = no fill). We’ll also add a label, which will appear upon hover.\n\n\nmake_neighborhood &lt;- function(){\n  neighborhood_wig &lt;- leaflet::leaflet() %&gt;% \n    leaflet::addProviderTiles(providers$CartoDB.Voyager) %&gt;% \n    leaflet::addPolygons(\n      color = \"#222\",\n      weight = 2,\n      opacity = 1,\n      fillOpacity = 0,\n      label = ~lapply(Label, htmltools::htmlEscape),\n      labelOptions = leaflet::labelOptions(direction = \"top\"),\n      data = neighborhoods_raw_sf\n    )\n  return(neighborhood_wig)\n}\n\nmake_neighborhood() %&gt;% \n  leaflet::addCircles(data = shootings_raw_sf)\n\nWarning in validateCoords(lng, lat, funcName): Data contains 12 rows with\neither missing or invalid lat/lon values and will be ignored\n\n\n\n\nLeaflet map adding a hover label, opacity, dark polygon borders.\n\n\n\n\nJitter points so that we can see them more clearly\n\nYou may have seen that some of the points in the plot above were darker than others. This is because we had overlapped multiple translucent circles. To avoid this issue, we will “jitter” our points, adding a small amount of random displacement in the x- and y-directions. To make this jitter consistent each time you render the plot, remember to set the seed value for the random jitter using set.seed().\n\n\nset.seed(1776)\nshootings_raw_sf &lt;- sf::st_jitter(shootings_raw_sf, factor = 0.0004)\n\nmake_neighborhood() %&gt;% \n  leaflet::addCircles(data = shootings_raw_sf)\n\nWarning in validateCoords(lng, lat, funcName): Data contains 12 rows with\neither missing or invalid lat/lon values and will be ignored\n\n\n\n\nLeaflet map with jittered points.\n\n\n\n\nAdd labels for clearer communication\n\nOur final set of aesthetic changes will be to our point layer. We add two new variables to our shootings dataset: a “Color” variable that encodes encodes the “fatal” variable into red and grey, and a “Popup” variable that summarizes key information about each shooting. This popup variable will appear in our map when we click on a point. In leaflet, labels appear upon hover, and popups appear upon click.\n\n\nCreate columns from shootings_raw_sf to define popup labels and point colors.\n\n\nshootings_labels_sf &lt;- data.table::as.data.table(shootings_raw_sf) %&gt;% \n  .[, `:=`(\n    Color = ifelse(fatal == 1, \"#900\", \"#222\"),\n    Popup = paste0(\n      \"&lt;b&gt;\", location, \"&lt;/b&gt;\",\n      \"&lt;br/&gt;&lt;i&gt;\", date_, \"&lt;/i&gt;\",\n      \"&lt;br/&gt;&lt;b&gt;Race:&lt;/b&gt; \", data.table::fcase(\n        race == \"B\", \"Black\",\n        race == \"W\", \"White\"\n      ),\n      \"&lt;br/&gt;&lt;b&gt;Sex:&lt;/b&gt; \", data.table::fcase(\n        sex == \"M\", \"Male\",\n        sex == \"F\", \"Female\"\n      ),\n      \"&lt;br/&gt;&lt;b&gt;Age:&lt;/b&gt; \", age,\n      \"&lt;br/&gt;&lt;b&gt;Wound:&lt;/b&gt; \", wound,\n      \"&lt;br/&gt;&lt;b&gt;Fatal?:&lt;/b&gt; \", data.table::fcase(\n        fatal == 1, \"Yes\",\n        fatal == 0, \"No\"\n      )\n    )\n  )] %&gt;% \n  .[, .(Color, Popup, geometry)] %&gt;% \n  sf::st_as_sf(.)\n\n\nIncorporate shootings_labels_sf over the neighborhood geometries.\n\n\nmake_neighborhood() %&gt;% \n  leaflet::addCircles(\n    color = ~Color,\n    popup = ~Popup,\n    data = shootings_labels_sf\n  )\n\nWarning in validateCoords(lng, lat, funcName): Data contains 12 rows with\neither missing or invalid lat/lon values and will be ignored\n\n\n\n\nLeaflet with shooting popup and point color\n\n\n\n\nChoropleths in leaflet\n\nChoropleths–maps in which each region is colored according to a summary statistic–are a powerful way to visualize data. In this example, let us suppose that we would like to show the total number of shootings in each neighborhood.\n\n\nJoin polygon data of neighborhoods_raw_sf with shootings_raw_sf.\n\n\nneighborhoods_valid_raw_sf &lt;- sf::st_make_valid(neighborhoods_raw_sf)\nneigh_shootings_join_sf &lt;- sf::st_join(neighborhoods_valid_raw_sf, shootings_raw_sf)\n\n\nConvert the join to a data.table, group, and create “total_shootings” variable.\n\n\nneighborhoods_raw_dt &lt;- data.table::as.data.table(neighborhoods_raw_sf)\n\nneigh_shootings_sf &lt;- data.table::as.data.table(neigh_shootings_join_sf) %&gt;% \n  .[, .(total_shootings = .N), by = Label] %&gt;% \n  neighborhoods_raw_dt[., on = c(\"Label\", \"Label\")] %&gt;% \n  sf::st_as_sf(.)\n\n\nMap the choropleth based on “total_shootings” variable.\n\n\npal &lt;- leaflet::colorNumeric(\n  \"YlOrRd\",\n  domain = neigh_shootings_sf$total_shootings\n)\n\nleaflet::leaflet(neigh_shootings_sf) %&gt;% \n  leaflet::addPolygons(\n    color = \"#222\",\n    weight = 2,\n    opacity = 1,\n    fillColor = ~pal(total_shootings),\n    fillOpacity = 0.7\n  )\n\n\n\n\n\n\n\nFinal map\n\nIn this final map, we add back our provider tiles, our label, and our highlight options, with no changes here from what had been done earlier in this post. We have also added a legend (and assigned the palette function to it), which describes the color range. Notice that we can change the opacity and location of the legend so that it is as unobtrusive as possible.\n\n\nleaflet::leaflet(neigh_shootings_sf) %&gt;% \n  leaflet::addPolygons(\n    color = \"#222\",\n    weight = 2,\n    opacity = 1,\n    fillColor = ~pal(total_shootings),\n    fillOpacity = 0.7,\n    label = ~lapply(Label, htmltools::HTML),\n    labelOptions = leaflet::labelOptions(direction = \"top\"),\n    highlightOptions = leaflet::highlightOptions(\n      color = \"#FFF\",\n      bringToFront = T\n    )\n  ) %&gt;% \n  leaflet::addLegend(\n    pal = pal,\n    values = ~total_shootings,\n    opacity = 0.7,\n    title = \"# shootings\",\n    position = \"topleft\"\n  )\n\n\n\nLeaflet final map with choropleth on shooting counts and neighborhood highlight",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Part 3: Making interactive maps with leaflet</span>"
    ]
  },
  {
    "objectID": "part_3.html#conclusion",
    "href": "part_3.html#conclusion",
    "title": "Part 3: Making interactive maps with leaflet",
    "section": "Conclusion",
    "text": "Conclusion\n\nWe would struggle to recreate and exact copy of ggplot2‘s maps in leaflet. But, that is to be expected. These two packages create two different types of maps–static and interactive–for different analytical purposes. What leaflet might lose in creating annotations and allowing for extremely precise aesthetic changes, it gains by allowing for paning, zooming, hovers, and popups.\n\n\nThink of these two packages as complimentary tools in your analytics arsenal. Think carefully about when to use each one so that you can display data clearly, insightfully, and intuitively.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Part 3: Making interactive maps with leaflet</span>"
    ]
  }
]